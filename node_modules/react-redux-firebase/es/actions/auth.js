'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateEmail = exports.updateAuth = exports.updateProfile = exports.verifyPasswordResetCode = exports.confirmPasswordReset = exports.resetPassword = exports.createUser = exports.logout = exports.login = exports.init = exports.createUserProfile = exports.watchUserProfile = exports.unWatchUserProfile = exports.dispatchLogin = exports.dispatchUnauthorizedError = exports.dispatchLoginError = undefined;

var _mapValues2 = require('lodash/mapValues');

var _mapValues3 = _interopRequireDefault(_mapValues2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _set2 = require('lodash/set');

var _set3 = _interopRequireDefault(_set2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _isFunction2 = require('lodash/isFunction');

var _isFunction3 = _interopRequireDefault(_isFunction2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _jwtDecode = require('jwt-decode');

var _jwtDecode2 = _interopRequireDefault(_jwtDecode);

var _constants = require('../constants');

var _auth = require('../utils/auth');

var _populate = require('../utils/populate');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var _Promise = typeof Promise === 'undefined' ? require('es6-promise').Promise : Promise;

var SET = _constants.actionTypes.SET,
    SET_PROFILE = _constants.actionTypes.SET_PROFILE,
    LOGIN = _constants.actionTypes.LOGIN,
    LOGOUT = _constants.actionTypes.LOGOUT,
    LOGIN_ERROR = _constants.actionTypes.LOGIN_ERROR,
    UNAUTHORIZED_ERROR = _constants.actionTypes.UNAUTHORIZED_ERROR,
    AUTHENTICATION_INIT_STARTED = _constants.actionTypes.AUTHENTICATION_INIT_STARTED,
    AUTHENTICATION_INIT_FINISHED = _constants.actionTypes.AUTHENTICATION_INIT_FINISHED;
var dispatchLoginError = exports.dispatchLoginError = function dispatchLoginError(dispatch, authError) {
  return dispatch({
    type: LOGIN_ERROR,
    authError: authError
  });
};

var dispatchUnauthorizedError = exports.dispatchUnauthorizedError = function dispatchUnauthorizedError(dispatch, authError) {
  return dispatch({
    type: UNAUTHORIZED_ERROR,
    authError: authError
  });
};

var dispatchLogin = exports.dispatchLogin = function dispatchLogin(dispatch, auth) {
  return dispatch({
    type: LOGIN,
    auth: auth,
    authError: null
  });
};

var unWatchUserProfile = exports.unWatchUserProfile = function unWatchUserProfile(firebase) {
  var authUid = firebase._.authUid;
  var userProfile = firebase._.config.userProfile;
  if (firebase._.profileWatch) {
    firebase.database().ref().child(userProfile + '/' + authUid).off('value', firebase._.profileWatch);
    firebase._.profileWatch = null;
  }
};

var watchUserProfile = exports.watchUserProfile = function watchUserProfile(dispatch, firebase) {
  var authUid = firebase._.authUid;
  var userProfile = firebase._.config.userProfile;
  unWatchUserProfile(firebase);

  if (firebase._.config.userProfile) {
    firebase._.profileWatch = firebase.database().ref().child(userProfile + '/' + authUid).on('value', function (snap) {
      var _firebase$_$config = firebase._.config,
          profileParamsToPopulate = _firebase$_$config.profileParamsToPopulate,
          autoPopulateProfile = _firebase$_$config.autoPopulateProfile,
          setProfilePopulateResults = _firebase$_$config.setProfilePopulateResults;

      if (!profileParamsToPopulate || !(0, _isArray3.default)(profileParamsToPopulate) && !(0, _isString3.default)(profileParamsToPopulate)) {
        dispatch({
          type: SET_PROFILE,
          profile: snap.val()
        });
      } else {
        (0, _populate.promisesForPopulate)(firebase, snap.key, snap.val(), profileParamsToPopulate).then(function (data) {
          if (autoPopulateProfile) {
            var populates = (0, _populate.getPopulateObjs)(profileParamsToPopulate);
            var profile = snap.val();
            (0, _forEach3.default)(populates, function (p) {
              var child = (0, _get3.default)(profile, p.child);
              var childType = (0, _populate.getChildType)(child);
              var populatedChild = void 0;

              switch (childType) {
                case 'object':
                  populatedChild = (0, _mapValues3.default)(child, function (value, key) {
                    if (value) {
                      return (0, _get3.default)(data, p.root + '.' + key);
                    }
                    return value;
                  });
                  break;

                case 'string':
                  populatedChild = (0, _get3.default)(data, p.root + '.' + child);
                  break;

                case 'array':
                  populatedChild = (0, _map3.default)(child, function (key) {
                    return (0, _get3.default)(data, p.root + '.' + key);
                  });
                  break;

                default:
                  populatedChild = child;
              }

              (0, _set3.default)(profile, p.child, populatedChild);
            });
            dispatch({
              type: SET_PROFILE,
              profile: profile
            });
          } else {
            dispatch({
              type: SET_PROFILE,
              profile: snap.val()
            });
          }

          if (setProfilePopulateResults) {
            (0, _forEach3.default)(data, function (result, path) {
              dispatch({
                type: SET,
                path: path,
                data: result,
                timestamp: Date.now(),
                requesting: false,
                requested: true
              });
            });
          }
        });
      }
    });
  }
};

var createUserProfile = exports.createUserProfile = function createUserProfile(dispatch, firebase, userData, profile) {
  if (!firebase._.config.userProfile) {
    return _Promise.resolve(userData);
  }
  var database = firebase.database,
      config = firebase._.config;

  try {
    if ((0, _isFunction3.default)(config.profileFactory)) {
      profile = config.profileFactory(userData, profile);
    }
    if ((0, _isFunction3.default)(config.profileDecorator)) {
      console.warn('profileDecorator is Depreceated and will be removed in future versions. Please use profileFactory.');
      profile = config.profileDecorator(userData, profile);
    }
  } catch (err) {
    console.error('Error occured within profileFactory function:', err.toString ? err.toString() : err);
    return _Promise.reject(err);
  }

  return database().ref().child(config.userProfile + '/' + userData.uid).once('value').then(function (profileSnap) {
    return !config.updateProfileOnLogin && profileSnap.val() !== null ? profileSnap.val() : profileSnap.ref.update(profile).then(function () {
      return profile;
    }).catch(function (err) {
      dispatchUnauthorizedError(dispatch, err);
      return _Promise.reject(err);
    });
  }).catch(function (err) {
    dispatchUnauthorizedError(dispatch, err);
    return _Promise.reject(err);
  });
};

var init = exports.init = function init(dispatch, firebase) {
  dispatch({ type: AUTHENTICATION_INIT_STARTED });

  firebase.auth().onAuthStateChanged(function (authData) {
    if (!authData) {
      if ((0, _isFunction3.default)(firebase._.config.onAuthStateChanged) && firebase._.config.enableEmptyAuthChanges) {
        firebase._.config.onAuthStateChanged(authData, firebase, dispatch);
      }
      return dispatch({ type: LOGOUT });
    }

    firebase._.authUid = authData.uid;
    watchUserProfile(dispatch, firebase);

    dispatchLogin(dispatch, authData);

    if ((0, _isFunction3.default)(firebase._.config.onAuthStateChanged)) {
      firebase._.config.onAuthStateChanged(authData, firebase, dispatch);
    }
  });

  if (firebase._.config.enableRedirectHandling) {
    firebase.auth().getRedirectResult().then(function (authData) {
      if (firebase._.config.onRedirectResult) {
        firebase._.config.onRedirectResult(authData, firebase, dispatch);
      }
      if (authData && authData.user) {
        var user = authData.user;


        firebase._.authUid = user.uid;
        watchUserProfile(dispatch, firebase);

        dispatchLogin(dispatch, user);

        createUserProfile(dispatch, firebase, user, {
          email: user.email,
          displayName: user.providerData[0].displayName || user.email,
          avatarUrl: user.providerData[0].photoURL,
          providerData: user.providerData
        });
      }
    }).catch(function (error) {
      dispatchLoginError(dispatch, error);
      return _Promise.reject(error);
    });
  }

  firebase.auth().currentUser;

  dispatch({ type: AUTHENTICATION_INIT_FINISHED });
};

var login = exports.login = function login(dispatch, firebase, credentials) {
  var _firebase$auth;

  dispatchLoginError(dispatch, null);

  var _getLoginMethodAndPar = (0, _auth.getLoginMethodAndParams)(firebase, credentials),
      method = _getLoginMethodAndPar.method,
      params = _getLoginMethodAndPar.params;

  return (_firebase$auth = firebase.auth())[method].apply(_firebase$auth, _toConsumableArray(params)).then(function (userData) {
    if (!userData) return _Promise.resolve(null);

    if (userData.email) return userData;

    if (method === 'signInWithCustomToken') {
      var _userData$toJSON = userData.toJSON(),
          accessToken = _userData$toJSON.stsTokenManager.accessToken,
          uid = _userData$toJSON.uid;

      var extraJWTData = (0, _omit3.default)((0, _jwtDecode2.default)(accessToken), _constants.defaultJWTProps);

      return createUserProfile(dispatch, firebase, { uid: uid }, _extends({}, extraJWTData, { uid: uid }));
    }

    var user = userData.user;


    return createUserProfile(dispatch, firebase, user, {
      email: user.email,
      displayName: user.providerData[0].displayName || user.email,
      avatarUrl: user.providerData[0].photoURL,
      providerData: user.providerData
    }).then(function (profile) {
      return _extends({ profile: profile }, userData);
    });
  }).catch(function (err) {
    dispatchLoginError(dispatch, err);
    return _Promise.reject(err);
  });
};

var logout = exports.logout = function logout(dispatch, firebase) {
  return firebase.auth().signOut().then(function () {
    dispatch({ type: LOGOUT });
    firebase._.authUid = null;
    unWatchUserProfile(firebase);
    return firebase;
  });
};

var createUser = exports.createUser = function createUser(dispatch, firebase, _ref, profile) {
  var email = _ref.email,
      password = _ref.password,
      signIn = _ref.signIn;

  dispatchLoginError(dispatch, null);

  if (!email || !password) {
    dispatchLoginError(dispatch, new Error('Email and Password are required to create user'));
    return _Promise.reject(new Error('Email and Password are Required'));
  }

  return firebase.auth().createUserWithEmailAndPassword(email, password).then(function (userData) {
    return firebase.auth().currentUser || !!signIn && signIn === false ? createUserProfile(dispatch, firebase, userData, profile || { email: email }) : login(dispatch, firebase, { email: email, password: password }).then(function () {
      return createUserProfile(dispatch, firebase, userData, profile || { email: email });
    }).catch(function (err) {
      if (err) {
        switch (err.code) {
          case 'auth/user-not-found':
            dispatchLoginError(dispatch, new Error('The specified user account does not exist.'));
            break;
          default:
            dispatchLoginError(dispatch, err);
        }
      }
      return _Promise.reject(err);
    });
  }).catch(function (err) {
    dispatchLoginError(dispatch, err);
    return _Promise.reject(err);
  });
};

var resetPassword = exports.resetPassword = function resetPassword(dispatch, firebase, email) {
  dispatchLoginError(dispatch, null);
  return firebase.auth().sendPasswordResetEmail(email).catch(function (err) {
    if (err) {
      switch (err.code) {
        case 'auth/user-not-found':
          dispatchLoginError(dispatch, new Error('The specified user account does not exist.'));
          break;
        default:
          dispatchLoginError(dispatch, err);
      }
      return _Promise.reject(err);
    }
  });
};

var confirmPasswordReset = exports.confirmPasswordReset = function confirmPasswordReset(dispatch, firebase, code, password) {
  dispatchLoginError(dispatch, null);
  return firebase.auth().confirmPasswordReset(code, password).catch(function (err) {
    if (err) {
      switch (err.code) {
        case 'auth/expired-action-code':
          dispatchLoginError(dispatch, new Error('The action code has expired.'));
          break;
        case 'auth/invalid-action-code':
          dispatchLoginError(dispatch, new Error('The action code is invalid.'));
          break;
        case 'auth/user-disabled':
          dispatchLoginError(dispatch, new Error('The user is disabled.'));
          break;
        case 'auth/user-not-found':
          dispatchLoginError(dispatch, new Error('The user is not found.'));
          break;
        case 'auth/weak-password':
          dispatchLoginError(dispatch, new Error('The password is not strong enough.'));
          break;
        default:
          dispatchLoginError(dispatch, err);
      }
      return _Promise.reject(err);
    }
  });
};

var verifyPasswordResetCode = exports.verifyPasswordResetCode = function verifyPasswordResetCode(dispatch, firebase, code) {
  dispatchLoginError(dispatch, null);
  return firebase.auth().verifyPasswordResetCode(code).catch(function (err) {
    if (err) {
      dispatchLoginError(dispatch, err);
    }
    return _Promise.reject(err);
  });
};

var updateProfile = exports.updateProfile = function updateProfile(dispatch, firebase, profileUpdate) {
  var database = firebase.database,
      _firebase$_ = firebase._,
      config = _firebase$_.config,
      authUid = _firebase$_.authUid;

  dispatch({
    type: _constants.actionTypes.PROFILE_UPDATE_START,
    payload: profileUpdate
  });
  var profileRef = database().ref(config.userProfile + '/' + authUid);
  return profileRef.update(profileUpdate).then(function () {
    return profileRef.once('value').then(function (snap) {
      dispatch({
        type: _constants.actionTypes.PROFILE_UPDATE_SUCCESS,
        payload: snap.val()
      });
      return snap.val();
    });
  }).catch(function (payload) {
    dispatch({
      type: _constants.actionTypes.PROFILE_UPDATE_ERROR,
      payload: payload
    });
  });
};

var updateAuth = exports.updateAuth = function updateAuth(dispatch, firebase, authUpdate, updateInProfile) {
  dispatch({
    type: _constants.actionTypes.AUTH_UPDATE_START,
    payload: authUpdate
  });
  if (!firebase.auth().currentUser) {
    var msg = 'User must be logged in to update auth.';
    dispatch({
      type: _constants.actionTypes.AUTH_UPDATE_ERROR,
      payload: msg
    });
    return _Promise.reject(msg);
  }
  return firebase.auth().currentUser.updateProfile(authUpdate).then(function (payload) {
    dispatch({
      type: _constants.actionTypes.AUTH_UPDATE_SUCCESS,
      payload: firebase.auth().currentUser
    });
    if (updateInProfile) {
      return updateProfile(dispatch, firebase, authUpdate);
    }
    return payload;
  }).catch(function (payload) {
    dispatch({
      type: _constants.actionTypes.AUTH_UPDATE_ERROR,
      payload: payload
    });
  });
};

var updateEmail = exports.updateEmail = function updateEmail(dispatch, firebase, newEmail, updateInProfile) {
  dispatch({
    type: _constants.actionTypes.EMAIL_UPDATE_START,
    payload: newEmail
  });
  if (!firebase.auth().currentUser) {
    var msg = 'User must be logged in to update email.';
    dispatch({
      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,
      payload: msg
    });
    return _Promise.reject(msg);
  }
  return firebase.auth().currentUser.updateEmail(newEmail).then(function (payload) {
    dispatch({
      type: _constants.actionTypes.EMAIL_UPDATE_SUCCESS,
      payload: newEmail
    });
    if (updateInProfile) {
      return updateProfile(dispatch, firebase, { email: newEmail });
    }
    return payload;
  }).catch(function (payload) {
    dispatch({
      type: _constants.actionTypes.EMAIL_UPDATE_ERROR,
      payload: payload
    });
  });
};

exports.default = {
  dispatchLoginError: dispatchLoginError,
  dispatchUnauthorizedError: dispatchUnauthorizedError,
  dispatchLogin: dispatchLogin,
  unWatchUserProfile: unWatchUserProfile,
  watchUserProfile: watchUserProfile,
  init: init,
  createUserProfile: createUserProfile,
  login: login,
  logout: logout,
  createUser: createUser,
  resetPassword: resetPassword,
  confirmPasswordReset: confirmPasswordReset,
  verifyPasswordResetCode: verifyPasswordResetCode,
  updateAuth: updateAuth,
  updateProfile: updateProfile,
  updateEmail: updateEmail
};